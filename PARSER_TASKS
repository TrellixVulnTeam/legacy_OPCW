
# TONIGHT
# [ ] Convert parser to be generative
# [ ] Postfix expressions
# [ ] Binary expressions
# [ ] Unary expressions
# [ ] Lots of parse tests for those
# [ ] Selection expressions / statements

# [ ] Fix adjacent selection statements
if cond { }
if cond { }

# [ ] Structure decls
struct Name {
    static s_member: bool,
    member: int32 = 329,
    mut mmember: int32
}

# [ ] Degenerate enumeration decls
enum Name {
    Member = 303,
    Other
}

enum Fixed: int {
    Some,
    Other
}

# [ ] Structure expressions
Name{member: 3021, mmember: 3899};
Name{mmember: 3899};

# [ ] Sequence expressions
Name{3420, 329};
Name{};

# [ ] Pointers
let x: int = 32;
let mut p: *int = &x;
let mut y: int = 36;
let pm: *mut int = &mut y;

let z = &x;
*z = 30; # error: immutable

let mut z = &x;
*z = 30; # error: immutable

let z = &mut x;
*z = 50; # ok

# [ ] Bitwise operations
342 & 32  # And
32 | 32   # Or
482 ^ 342 # Xor
!34289    # Not

# [ ] Implement
implement typename {
    def method(self) { }
    def method(mut self) { }
}

# Parameter passing is by-reference
def a(mut x: Name) { x }
a(Name{30, 320}) # error

let mut n = Name{}
a(n) # ok

# [ ] Mutable params
def extra(mut x: int) { }

# [ ] Function expressions
# single-param doesn't need params
# multi-param and no-param needs params
# return type is implicit
let id = x -> x;
let sq = x -> x * x;
let odds = evens.map(v -> v + 1);
let empty = () -> {};

# [ ] Repeat evaluation
loop { }
while condition { }

# [ ] Arrays
let b: int[];
let b140: int[140];

# [ ] Array expressions
let m = [1, 2, 3, 4, 943, 03];
let mut mm = [1, 2, 3, 4, 943, 03];

# [ ] Generics
struct Vector<T> { x: T, y: T, z: T }
implement<T> Vector<T> {
    def some(a: T) { }
}

def func<T>(x: T) { }

func<T>(20);

let m: Vector<int>;

let a: type(Vector<int>.x) = 10;

Vector<bool>.some(false)
