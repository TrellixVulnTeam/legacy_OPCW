# [X] Add `code.FunctionType`
# [X] Emplace functions with their type
# [X] Generate call expressions
# [X] Add `assert` built-in
# [X] Add top-level `main`
# [X] Remove `:=`
# [X] Move `.` to a postfix operator
# [ ] Add semantic analysis pass for contextual type analysis
# [ ]   - Determine the type of integer literals
# [ ]   - Determine the type of float literals
# [ ] Generate integral literals
# [ ] Generate float literals
# [ ] Generate static slot initializers
# [ ] Parse / generate `assert` statement
# [ ] Parse / generate logical operations (short-circuiting): "and", "or"
# [ ] Parse Inequality as "!="
# [ ] Parse / generate relational operations: "<", ">", "<=", ">=", "!=", "=="
# [ ] Parse / generate bitwise operations: "&", "|", "!", "^"
# [ ] Add location spans to tokenizer, parser, generator
# [ ] Harden with lots more parse-fail tests (at least 30)
# [ ] Begin hardening the generator with lots of run-fail tests (at least 30)
# [ ] Parse / generate type expressions: tuple, function, array
# [ ] Parse / generate structure types / expressions (record and sequence)
# [ ] Interleave the parsing of structure expressions and block statements
# [ ] Parse / generate function types
# [ ] Parse / generate function expressions
# [ ] Parse / generate tuple types / expressions
# [ ] Parse / generate arrays types
# [ ] Parse / generate arrays expressions
# [ ] Account for integer / float promotion in operations
# [ ] Handle data layout and target triple
# [ ] Allow machine dependent integer types
# [ ] Generate selection expressions and operations
# [ ] Parse / generate `while` / `loop` statements
# [ ] Implement local scope and generate local slots
# [ ] Add semantic analysis pass for initialization type analysis
# [ ]   - Determine the type of local slots
# [ ] Add semantic analysis pass for usage type analysis
# [ ]   - Further determine the type of local slots
# [ ]   - Further determine the type of integer and floating types
# [ ] Parse / generate cast expressions






# PASS  A - Build global symbol table consisting of "just" names and `kinds`
#           This means that now we'll have a "_.main" entry that is identified
#           as a "Function". All information from the AST is transferred
#           into the IR. Flatten modules.

# PASS  B - Resolve the opaque type of each "declaration" into
#           an initial `code.*Type`.

# PASS  C - Resolve the full type of each "declaration" (function parameters
#           and return type, struct members, static type). Expand `type(X)`
#           for type deferrence here.

# PASS  D - Resolve the LLVM type of each "declaration"; detect unresolvable
#           type reference recursion that may have happened due to `type(X)`.

# PASS  E - Analyze usage and initialization of local declarations
#           to infer type

# PASS  F - Analyze context of literal expressions to infer their type

# PASS  G - Generate static slot declaration initialization sequences. Note
#           these can also be recursive as they may refer to
#           other declarations.

# Initial generation runs pass A - D and F - G. On function definition
# generation we run pass E - F.


# [ ] Traits
# [ ] Enumerations
# [ ] Parameterized types (bounded by Traits)
# [ ] Parameterized functions (bounded by Traits)
# [ ] Pattern matching `match`
# [ ] Destructors

# TODAY -----------------------------------------------------------------------

# Note that `resolve_type` needs to evolve into type_check(..) in
# in the future. Or with `type_check` and `resolve_type`.. one of them
# needs to use the other (so we don't duplicate error handling here).

# [ ] Change param `explicit` of resolve_type_* to `typename` as a typename
#     can not appear inside of a normal expression or a type(..) expression.

# [ ] Add all binary and unary operators to type resolution

# [ ] Add function declarations to type resolution

# [ ] Add function calling to type resolution

# [ ] Add functions themselves to type resolution

# [ ] Ensure paths work in type deferrence

# [ ] Add function declarations to `gen_decl` pass

# [ ] Add structure declarations to parser and generator

# [ ] Add `gen_def` pass

# [ ] Add statics to `gen_def`

# [ ] Add functions to `gen_def`

# [ ] Add modules to `gen_def`

# [ ] Add structures to `gen_def`

# [ ] Add all binary and unary operators to `gen_def`

# [ ] Add at least 15 `run-fail` tests (test each error message at least twice)

# [ ] Add at least 15 `parse-fail` tests (test each error message at least twice)

struct Point { x: int, y: int }

def some(o: Point) -> type(Point.x) { o.x }
