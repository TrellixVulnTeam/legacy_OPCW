# [x] Parse import statements
# [x] Tokenizer operates on "tokens" (not "integers")
#     Fixes problem with "consecutive" identifiers or strings, etc.
# [.] Driver (getopt?)
# [x]   » arrow --version
# [ ]   » arrow -o out
# [x]   » arrow < in.as
# [x]   » arrow in.as
# [x] Module Import (from source)
# [x] "Imported" module should not share scope with the "importing" module.
# [ ] Top-level modules (files) should not be able to be referred to by module name.
# [ ] Module import "set" (re-importing modules just extends its referencable scope)
# [ ] Mutual recursion tests with importing (circular imports)
# [ ] Mutable parameters in "arrow" functions
# [ ] Implement (attached methods)
# [ ] Implement (instance methods)
# [ ] Logical operations: `and`, `or`
# [ ] divergence in the type system; a divergent expression is one that
#     does not continue. `return ..` is divergent -- `exit(0)` is divergent
# [ ] promote aggregates to `sret` parameters (function body and call builders)
# [ ] integral expressions don't carry the target type through
# [ ] refactor selection statements so that they do not require ";" afterwords
# [ ] rethink conditional expression parsing so that `x if c else y = 30` works without parens
# [ ] function types
# [ ] assign named functions to slots (`to_value`)
# [ ] function expressions
# [ ] remove "static", module-scoped "let" bindings get promoted to what "static" was
# [ ] Name hoisting and extraction done for "let" bindings
# [ ] Name hoisting and extraction done on each block
# [ ] change "def" to "let" for functions -- let main(): int -> { }
# [ ] Remove "def" in extern bindings
# [ ] Variadic parameter support on extern functions
# [ ] "static" context is not preserved through arithmetic
# [x] cast integer to pointer of struct dies as the initializer for static slots
# [x] allow "." in typename
# [ ] allow "constant" expressions inside of [..]
# [ ] local or relative imports
