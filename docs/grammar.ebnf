
top = { module-statement } ;

module-statement =
  statement
| import-statement ";"
| foreign-statement ";"
| module-declaration
| type-declaration
| struct-declaration
| enum-declaration
;

statement =
  local-declaration ";"
| static-declaration ";"
| function-declaration
| expression ";"
| iteration-statement
| selection-statement
| use-statement ";"
| break-statement ";"
| continue-statement ";"
| unsafe-statement
| return-statement ";"
| "{" { statement } "}"
;

return-statement = "return" [ expression ] ;

break-statement = "break" ;

continue-statement = "continue" ;

function-declaration =
  "def" identifier "(" [ parameter { "," parameter } [ "," ] ] ")" [ "->" type ] "{" { statement } "}" ;
;

parameter =
  [ "&" ] [ "mut" ] identifier ":" type [ "=" expression ]
;

selection-expression =
  "if" expression "{" statement "}"
  "if" expression "{" statement "}" "else" statement
;

selection-statement =
  selection-expression
| statement "if" expression ";"
;

iteration-statement =
  "while" expression "{" { statement } "}"
| "loop" expression "{" { statement } "}"
;

(* An unsafe statement block groups together a set of statements to be
 * executed in an unsafe context. Some operations are only possible in an
 * unsafe context.
 *)
unsafe-statement = "unsafe" "{" { statement } "}" ;

primary-expression =
  identifier
| literal
| "(" expression ")"
;

literal =
  dec-integer
| hex-integer
| bin-integer
| oct-integer
| float
| string
;

postfix-expression =
  primary-expression
| postfix-expression "[" expression "]"
| postfix-expression "(" [ arguments ] ")"
| postfix-expression "." identifier
| postfix-expression "^"
;

unary-expression =
  postfix-expression
| "+" postfix-expression
| "-" postfix-expression
| "&" postfix-expression
| "not" postfix-expression
;

cast-expression =
  unary-expression
| cast-expression "as" type
;

multiplicate-expression =
  cast-expression
| multiplicate-expression "*" cast-expression
| multiplicate-expression "/" cast-expression
| multiplicate-expression "%" cast-expression
;

additive-expression =
  multiplicate-expression
| additive-expression "+" multiplicate-expression
| additive-expression "-" multiplicate-expression
;

relational-expression =
  additive-expression
| relational-expression "<" additive-expression
| relational-expression ">" additive-expression
| relational-expression "<=" additive-expression
| relational-expression ">=" additive-expression
;

equality-expression =
  relational-expression
| equality-expression "==" relational-expression
| equality-expression "<>" relational-expression
;

and-expression =
  equality-expression
| and-expression "and" equality-expression
;

or-expression =
  and-expression
| or-expression "or" and-expression
;

conditional-expression =
  or-expression
| conditional-expression "if" expression "else" conditional-expression
;

expression =
  conditional-expression
| selection-expression
;

(* A local declaration declares a slot that is locally allocated (normally
 * on the stack). Nested functions do NOT inherit their parent's local
 * declarations (but nested closures can).
 *)
local-declaration-member = [ "mut" ] identifier
local-declaration =
  "let" local-declaration-member [ ":" type ] [ "=" expression ]
| "let" [ "mut" ] "(" local-declaration-member { "," local-declaration-member } ")" [ ":" type ] [ "=" expression ]
| [ "mut" ] local-declaration-member ":" "=" expression
| [ "mut" ] "(" local-declaration-member { "," local-declaration-member } ")" ":" "=" expression
;

(* A static declaration declares a slot that is globally allocated (normally
 * in the .rdata or .data section of the final executable). Nested functions
 * inherit their parent's static declarations.
 *
 * NOTE: It is considered "unsafe" to mutate static slots.
 *)
static-declaration =
  "static" [ "mut" ] identifier [ ":" type ] [ "=" expression ] ;

(* An import statement attempts to find the named module (
 * replacing "." with the system defined path separator) and "import" it
 * in the current module scope.
 *
 * NOTE: "import std.ext" makes "ext" available in the current module scope
 *)
import-statement = "import" identifier { "." identifier } ;

(* A foreign statement bridges a foreign environment with the current
 * module. This includes declaring external functions, types, constants, etc.
 *
 * NOTE: The standard only mandates implementation of the "C" environment
 *       though additional foreign environments may be implemented through
 *       the foreign interface extension system.
 *)
foreign-statement = "foreign" string "import" string ;

(* A type declaration declares a "new" type with identical size and semantics
 * but with an empty method set.
 *)
type-declaration = "type" identifier "=" type ;

(* A struct declaration declares a new "product" type identical in semantics
 * to a struct declaration in "C".
 *)
struct-declaration = "struct" identifier "{" [ struct-member { "," struct-member } [ "," ] ] "}" ;
struct-member = [ "static" ] [ "&" ] [ "mut" ] identifier ":" type ;

(* An enum declaration declares a new "sum" type. For a "sum" type "T" (also
 * known as a "tagged union") declares a set of type "constructors" for which
 * a "T" may be constructed. It is a type-safe construct in that
 * a slot of "T" knows what type constructor it was constructed from.
 *
 * NOTE: The degenerate case is identical in semantics to an "enum class"
 *       from "C++".
 *)
enum-declaration = "enum" identifier [ ":" type ] "{" [ enum-variant { "," enum-variant } ] "}" ;
enum-variant =
  identifier [ "(" type { "," type } ")" ] [ "=" expression ]
| identifier [ "(" named-member { "," named-member } ")" ] [ "=" expression ]
;

(* A module declaration declares a named "module" that is close in semantics
 * to a "namespace" declaration from "C++" (except for namespace merging of
 * which there is none of).
 *)
module-declaration = identifier "{" { module-statement } "}" ;
