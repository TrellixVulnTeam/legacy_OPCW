# [X] Add `code.FunctionType`
# [X] Emplace functions with their type
# [X] Generate call expressions
# [X] Add `assert` built-in
# [X] Add top-level `main`
# [X] Remove `:=`
# [X] Move `.` to a postfix operator
# [ ] Add semantic analysis pass for contextual type analysis
# [ ]   - Determine the type of integer literals
# [ ]   - Determine the type of float literals
# [ ] Generate integral literals
# [ ] Generate float literals
# [ ] Generate static slot initializers
# [ ] Parse / generate `assert` statement
# [ ] Parse / generate logical operations (short-circuiting): "and", "or"
# [ ] Parse Inequality as "!="
# [ ] Parse / generate relational operations: "<", ">", "<=", ">=", "!=", "=="
# [ ] Parse / generate bitwise operations: "&", "|", "!", "^"
# [ ] Add location spans to tokenizer, parser, generator
# [ ] Harden with lots more parse-fail tests (at least 30)
# [ ] Begin hardening the generator with lots of run-fail tests (at least 30)
# [ ] Parse / generate type expressions: tuple, function, array
# [ ] Parse / generate structure types / expressions (record and sequence)
# [ ] Interleave the parsing of structure expressions and block statements
# [ ] Parse / generate function types
# [ ] Parse / generate function expressions
# [ ] Parse / generate tuple types / expressions
# [ ] Parse / generate arrays types
# [ ] Parse / generate arrays expressions
# [ ] Account for integer / float promotion in operations
# [ ] Handle data layout and target triple
# [ ] Allow machine dependent integer types
# [ ] Generate selection expressions and operations
# [ ] Parse / generate `while` / `loop` statements
# [ ] Implement local scope and generate local slots
# [ ] Add semantic analysis pass for initialization type analysis
# [ ]   - Determine the type of local slots
# [ ] Add semantic analysis pass for usage type analysis
# [ ]   - Further determine the type of local slots
# [ ]   - Further determine the type of integer and floating types
# [ ] Parse / generate cast expressions






# PASS  A - Build global symbol table consisting of "just" names and `kinds`
#           This means that now we'll have a "_.main" entry that is identified
#           as a "Function". All information from the AST is transferred
#           into the IR. Flatten modules.

# PASS  B - Resolve the opaque type of each "declaration" into
#           an initial `code.*Type`.

# PASS  C - Resolve the full type of each "declaration" (function parameters
#           and return type, struct members, static type). Expand `type(X)`
#           for type deferrence here.

# PASS  D - Resolve the LLVM type of each "declaration"; detect unresolvable
#           type reference recursion that may have happened due to `type(X)`.

# PASS  E - Analyze usage and initialization of local declarations
#           to infer type

# PASS  F - Analyze context of literal expressions to infer their type

# PASS  G - Generate static slot declaration initialization sequences. Note
#           these can also be recursive as they may refer to
#           other declarations.

# Initial generation runs pass A - D and F - G. On function definition
# generation we run pass E - F.

assert(that()(20) == 40);

def that() -> type(some) { some; }

def some(a: type(x)) -> type(x * 2) { a * 2; }

static x: uint = 40;

# [ ] Traits
# [ ] Enumerations
